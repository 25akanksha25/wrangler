# Split to Rows

SPLIT-TO-ROWS directive splits a column based on separator and makes a copy of the record for each column value
generated by splitting.

## Syntax

```
 split-to-rows <column> <separator>
```

The ```column``` is split based on the ```separator```. ```separator``` can be defined as a regular expression.

## Usage Notes

The SPLIT-TO-ROW directive supports splitting on the column data using a regular expression. Regular expression
allows one to use complex search patterns to split the data in the column. It supports all the standard regular
expression constructs supported by Java pattern.

If the ```separator``` regular expression pattern do not match any part of input string, then no additional
rows are generated. But in case when there is a match and the match splits the input string into 'n' strings, then
 'n' rows copying other columns will be generated.

So for example, if we have a ```separator``` pattern as "\n" over a string

```This will be split 1\nThis will be split 2```

will generate two splits

```
  [1] This will be split 1
  [2] This will be split 2
```

So, a single input record would generate two output record with the ```column``` having above values each.

> NOTE : This directive can only operate on string type columns.

## Example

Let's look at an example that will demostrate the behavior of SPLIT-TO-ROWS directive. Let's start with a record

```
  {
    "id" : 1,
    "codes" : "USD|AUD|AMD|XCD",
  }
```

applying following SPLIT-TO-ROWS directive

```
  split-to-rows codes \\|
```
> NOTE: The backslashes are to escape the pipe(|) as it's a option separator in regex pattern.

would result in four (4) records being generated with each split value being assigned to the column ```codes```

```
  {
    "id" : 1,
    "codes" : USD,
  }
  {
    "id" : 1,
    "codes" : AUD,
  }
  {
    "id" : 1,
    "codes" : AMD,
  }
  {
    "id" : 1,
    "codes" : XCD,
  }
```

