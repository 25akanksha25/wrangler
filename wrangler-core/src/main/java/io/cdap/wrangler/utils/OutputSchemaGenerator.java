/*
 * Copyright Â© 2023 Cask Data, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

package io.cdap.wrangler.utils;

import io.cdap.cdap.api.data.schema.Schema;
import io.cdap.wrangler.api.Directive;

import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import javax.annotation.Nullable;

/**
 * This class can be used to generate the output schema after executing a set of directives. A list is maintained
 * where each element is a map of fieldName --> value. Each element of the list corresponds to a directive in the list
 * provided during initialization. Hence, each map represents the fields present across all output rows generated by a
 * directive after execution.
 */
public class OutputSchemaGenerator {
  private static final SchemaConverter SCHEMA_GENERATOR = new SchemaConverter();

  private final Schema inputSchema;
  private final List<Directive> directives;
  private final int directiveCount;
  private final List<Map<String, Object>> directiveOutputFieldMaps;

  public OutputSchemaGenerator(Schema inputSchema, List<Directive> directives) {
    this.inputSchema = inputSchema;
    this.directives = directives;
    this.directiveCount = directives.size();
    directiveOutputFieldMaps = new ArrayList<>();
    for (int i = 0; i < directiveCount; i++) {
      directiveOutputFieldMaps.add(new LinkedHashMap<>());
    }
  }

  /**
   * Method to add a field in output generated by a directive. The field is added if not already present.
   * Existing value is only overwritten when given fieldValue is not null and current value is null.
   * @param directiveIndex index of the directive in recipe
   * @param fieldName name of the field (column name)
   * @param fieldValue value (can be null)
   */
  public void addDirectiveField(int directiveIndex, String fieldName, @Nullable Object fieldValue) {
    Map<String, Object> directiveOutputFields = directiveOutputFieldMaps.get(directiveIndex);
    if (directiveOutputFields.containsKey(fieldName)) {
      // If existing value is null, override with this non-null value
      if (fieldValue != null && directiveOutputFields.get(fieldName) == null) {
        directiveOutputFields.put(fieldName, fieldValue);
      }
    } else {
      directiveOutputFields.putIfAbsent(fieldName, fieldValue);
    }
  }

  /**
   * Method to generate the output schema after applying all directives. Intermediate schema is generated using
   * the fields in corresponding map only if the directive does not provide an implementation
   * of the {@link Directive#getOutputSchema(Schema)} method
   * @return {@link Schema} outputSchema after all directives are applied
   */
  public Schema generateOutputSchema() throws RecordConvertorException {
    return generateIntermediateSchema(directiveCount);
  }

  /**
   * Method to generate the intermediate schema after applying all directives until (and including) i'th directive in
   * the recipe. Intermediate schema is generated using
   * the fields in corresponding map only if the directive does not provide an implementation
   * of the {@link Directive#getOutputSchema(Schema)} method
   * @param directiveIndex index until (and including) which schema should be generated
   * @return {@link Schema} intermediate schema after the directives are applied
   */
  public Schema generateIntermediateSchema(int directiveIndex) throws RecordConvertorException {
    Schema schema = inputSchema;
    for (int i = 0; i < directiveIndex; i++) {
      Schema directiveOutputSchema = directives.get(i).getOutputSchema(schema);
      schema = directiveOutputSchema != null ? directiveOutputSchema :
        generateDirectiveOutputSchema(schema, directiveOutputFieldMaps.get(i));
    }
    return schema;
  }

  // Given the schema from previous step and output of current directive, generates the directive output schema.
  private Schema generateDirectiveOutputSchema(Schema inputSchema, Map<String, Object> output)
    throws RecordConvertorException {
    List<Schema.Field> outputFields = new LinkedList<>();
    for (String fieldName : output.keySet()) {
      Object fieldValue = output.get(fieldName);

      Schema existing = inputSchema.getField(fieldName) != null ? inputSchema.getField(fieldName).getSchema() : null;
      Schema generated = fieldValue != null && !isValidSchemaForValue(existing, fieldValue) ?
        SCHEMA_GENERATOR.getSchema(fieldValue, fieldName) : null;

      if (generated != null) {
        outputFields.add(Schema.Field.of(fieldName, generated));
      } else if (existing != null) {
        outputFields.add(Schema.Field.of(fieldName, existing));
      } else {
        outputFields.add(Schema.Field.of(fieldName, Schema.of(Schema.Type.NULL)));
      }
    }
    return Schema.recordOf("output", outputFields);
  }

  // Checks whether the provided input schema is of valid type for given object
  private boolean isValidSchemaForValue(@Nullable Schema schema, Object value) throws RecordConvertorException {
    if (schema == null) {
      return false;
    }
    Schema generated = SCHEMA_GENERATOR.getSchema(value, "temp_field_name");
    generated = generated.isNullable() ? generated.getNonNullable() : generated;
    schema = schema.isNullable() ? schema.getNonNullable() : schema;
    return generated.getType().equals(schema.getType());
  }
}
